#include "IntListModel.h"

// Конструктор класса модели списка целых чисел служит для инициализации
// атрибута m_list списком чисел и передачи указателя на объект предка унаследованному
// классу.
IntListModel::IntListModel(const QList<int>& list, QObject* pobj/*=0*/)
: QAbstractListModel(pobj)
, m_list(list)
{
}

// Посредством интерфейса модели, которую мы реализовали для связи со структурой данных,
// опрашиваемых представлением, метод data() возвращает интересующую
// представление информацию об элементе в объекте класса QVariant. Помимо индекса, в этот
// метод передаются значения ролей. В нашем случае, если они предназначены для отображения
// (Qt::DisplayRole) или редактирования (Qt::EditRole), мы возвращаем значение, записанное
// в атрибуте, представляющем собой список целых чисел, на позиции строки. Если
// роль не предназначена для отображения или редактирования, или же представление
// запросит о данных, которых мы не имеем, то возвратим пустой объект QVariant и тем самым
// укажем на то, что не располагаем этими данными.
QVariant IntListModel::data(const QModelIndex& index, int nRole) const
{
    if (!index.isValid()) {
        return QVariant();
    }
    if (index.row() < 0 || index.row() >= m_list.size()) {
        return QVariant();
    }

    return (nRole == Qt::DisplayRole || nRole == Qt::EditRole)
            ? m_list.at(index.row())
            : QVariant();
}

// Для установки значения в методе setData() требуются три параметра: индекс, значение и
// роль.
bool IntListModel::setData(const QModelIndex& index,
                           const QVariant& value,
                           int nRole)
{
    // Прежде всего мы проверяем индекс вызовом метода isValid().
    if (index.isValid() && nRole == Qt::EditRole) {

        // Если
        // индекс не пуст, а роль предназначена для редактирования, то мы заменяем существующее
        // значение в атрибуте списка (m_list) новым, используя метод replace().
        // Заметьте, что перед
        // тем как провести замену, мы должны преобразовать значение к нужному нам типу. В нашем
        // случае мы преобразуем атрибут value класса QVariant к целому типу при помощи шаблонного
        // метода QVariant: :value<T> (), параметризовав его типом int. Эту конструкцию
        // можно заменить методом QVariant::toInt().
        m_list.replace(index.row(), value.value<int>());

        // После замены отправляем сигнал
        // dataChanged(), что необходимо для того, чтобы все подсоединенные к модели представления
        // могли незамедлительно обновить свое содержимое.
        emit dataChanged(index, index);

        // Возвращаемое нами (из метода)
        // значение true сообщает об успешно проведенной операции установки данных, а false сообщает
        // представлению об ошибке .
        return true;
    }
    return false;
}

// Метод rowCount() должен сообщать о количестве строк.
// Количество строк модели соответствует количеству элементов, содержащихся в атрибуте
// списка целых чисел (m_list). Если индекс предка вдруг окажется действительным, то мы
// должны вернуть значение 0, так как это модель списка, и в ней не должно быть ни предков,
// ни дочерних элементов.
int IntListModel::rowCount(const QModelIndex& parent/*=QModelindex()*/) const
{
    if (parent.isValid())
        return 0;
    return m_list.size();
}

// Метод headerData() нужен для того, чтобы модель была в состоянии
// подписывать горизонтальные и вертикальные секции заголовков, которыми располагают
// иерархическое и табличное представления. Иерархическое представление имеет только горизонтальные
// заголовки, табличное представление располагает обоими типами заголовков
// (горизонтальными и вертикальными). Если представление запрашивает надпись для горизонтального
// заголовка, то мы возвращаем строку "NumЬer", а для вертикальных секций
// заголовков возвращается номер переданной секции.
QVariant IntListModel::headerData(int nSection,
                                  Qt::Orientation orientation,
                                  int nRole/*=DisplayRole*/) const
{
    if (nRole != Qt::DisplayRole) {
        return QVariant();
    }

    return (orientation == Qt::Horizontal) ? QString("Number") : QString::number(nSection);
}

// Дпя того чтобы предоставить возможность редактирования элементов, метод flags() возвращает
// для каждого элемента унаследованное значение с добавлением флага
// Qt::ItemIsEditable. Если индекс пуст, то возвращается значение без добавлений.
Qt::ItemFlags IntListModel::flags(const QModelIndex& index) const
{
    Qt::ItemFlags flags = QAbstractListModel::flags(index);
    return index.isValid() ? (flags | Qt::ItemIsEditable) : flags;
}

// Метод insertRows() принимает в качестве входных параметров: позицию
// для вставки nRow, количество элементов, которые с этой позиции необходимо вставить
// nCount, и индекс предка.
bool IntListModel::insertRows(int nRow,
                              int nCount,
                              const QModelIndex& parent/*=QModelindex()*/)
{
    // Если индекс предка является действительным, то мы покидаем
    // этот метод, так как недопустимо, чтобы модель списка содержала элементы предков.
    if (parent.isValid()) {
        return false;
    }

    // Теперь,
    // прежде чем приступить к вставке элементов, мы обязаны вызвать метод
    // QAbstractListitem::beginInsertRows() - это нужно для того, чтобы модель смогла уведомить
    // об этом всех заинтересованных в ее данных - например, виджеты представлений,
    // подсоединенные к ней. В этот метод нужно передать: индекс, начальную nRow и конечную
    // позиции для вставки элементов. Конечную позицию мы вычисляем, прибавив к начальной
    // позиции количество элементов и отняв единицу.
    beginInsertRows(QModelIndex(), nRow, nRow + nCount - 1);

    for (int i = 0; i < nCount; ++i) {
        // В цикле вставка элементов производится
        // вызовом метода QList<T>::insert() - каждый новый вставленный элемент получает значение
        // 0.
        m_list.insert(nRow, 0);
    }

    // Проделав изменение со списком m_list, мы, опять же, обязаны уведомить, что завершили
    // процесс изменения данных, всех заинтересованных в этом. Для этого мы вызываем
    // метод QAbstractListitem::endInsertRows().
    endInsertRows();

    return true;
}

// Реализация метода removeRows() очень похожа на реализацию метода
// insertRows() с той лишь разницей, что происходит удаление элементов.
bool IntListModel::removeRows(int nRow,
                              int nCount,
                              const QModelIndex& parent/*=QМodelindex()*/)
{
    if (parent.isValid()) {
        return false;
    }

    // Для того чтобы модель могла уведомить
    // все связанные с ней объекты о том, что начнут производиться изменения, вызываем
    // метод QAbstractListitem::beginRemoveRows().
    beginRemoveRows(QModelIndex(), nRow, nRow + nCount - 1);

    for (int i = 0; i < nCount; ++i) {
        m_list.removeAt(nRow);  // используется метод QList<T>::removeAt().
    }

    // По завершении изменений вызываем метод QAbstractListitem::endRemoveRows().
    endRemoveRows();

    return true;
}