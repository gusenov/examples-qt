import QtQuick 2.13
import QtQuick.Window 2.13
import QtQuick.Controls 1.4

Window {
    visible: true
    width: 640
    height: 480
    title: qsTr("Hello World")

    TabView {
        anchors.fill: parent
        Tab {
            title: "onPressed и onReleased"




            // Прямоугольная
            // область, которая реагирует на нажатие левой и правой кнопок мыши и отпускание
            // кнопки мыши изменением цвета:

            // Светло-зеленый прямоугольник с текстом (элемент техt), который
            // отцентрирован по вертикали и горизонтали:
            Rectangle {
                width: txt.width + 20
                height: txt.height + 20
                color: "lightgreen"
                Text {
                    id: txt
                    anchors.centerIn: parent
                    text: "<h1>Click Me!<br>(use left or right mouse button)</h1>"
                    horizontalAlignment: Text.AlignHCenter
                }

                // Для получения событий мыши в QML служат специальные элементы, которые называются
                // MouseArea - область мыши. То, что они являются элементами, дает возможность устанавливать
                // их расположение и изменять размеры как у обычных элементов. По своей сути они
                // представляют собой прямоугольные области, определяющие регионы, в которых должен
                // осуществляться ввод информации от мыши.

                // Для того чтобы иметь возможность
                // реагировать на нажатия кнопок мыши пользователем мы создаем область
                // мыши (элемент MouseArea), которая является потомком элемента верхнего уровня
                // Rectangle:
                MouseArea {

                    // Присваиваем свойству fill элемент предка, что позволяет провести фиксацию,
                    // которая осуществит заполнение всей области предка. Она и станет областью для получения
                    // и обработки событий, которые будет совершать пользователь с помощью мыши.
                    anchors.fill: parent

                    // В свойстве acceptedButtons ограничиваем срабатывание
                    // наших обработчиков сигналов только этими кнопками:
                    acceptedButtons: Qt.LeftButton | Qt.RightButton


                    // Свойства onPressed и onReleased будут исполнять код при нажатии
                    // и при отпускании кнопки мыши. Эти свойства являются на самом деле обработчиками сигналов,
                    // а все обработчики сигналов имеют префикс on. В нашем примере, по аналогии
                    // с Qt, вы можете представить, что это слоты, которые будут вызываться при нажатии и отпускании
                    // кнопок мыши. В свойствах onPressed и onReleased мы осуществляем изменения
                    // цвета текста. Некоторые сигналы содержат в себе дополнительную информацию, к которой
                    // можно получить доступ, используя имя.

                    // Обработчик сигнала onPressed
                    // получает дополнительный параметр mouse, который мы используем, чтобы узнать, какая
                    // именно из кнопок мыши была нажата.
                    onPressed: {
                        if (mouse.button === Qt.RightButton) {
                            // При нажатии правой кнопки заполняем окно красным
                            // цветом:
                            parent.color = "red"
                        } else {
                            // В ином случае - синим:
                            parent.color = "blue"
                        }
                    }

                    onReleased: parent.color = "lightgreen"
                }
            }




        }
        Tab {
            title: "hoverEnabled"




            // При наведении
            // курсора мыши на область окна в нем должно будет происходить только изменение
            // цвета:

            Rectangle {
                width: 200
                height: 200
                color: mousearea.containsMouse ? "red" : "lightgreen"

                Text {
                    anchors.centerIn: parent
                    text: "<h1>Hover Me!</h1>"
                }


                // Мы задали область мыши и идентификатор mousearea, которым воспользовались,
                // чтобы сослаться на него из предка (элемент Rectangle) и получить информацию
                // о том, находится ли курсор мыши поверх этой области или нет. В зависимости от этого мы
                // и присваиваем цвет для заполнения окна.
                MouseArea {
                    id: mousearea
                    anchors.fill: parent

                    // В области мыши свойству hoverEnabled присваиваем значение true.
                    // Это позволяет элементу
                    // MouseArea реагировать на подведение мыши.
                    hoverEnabled: true
                }
            }




        }
        Tab {
            title: "onEntered и onExit"




            // Свойства onEntered и onExit исполняют код, который вызывается при попадании курсора мыши
            // в область элемента (то есть в область мыши) и при покидании им этой области.

            Rectangle {
                width: 200
                height: 200
                color: "lightgreen"

                Text {
                    text: "<h1>Hover Me!</h1>"
                    anchors.centerIn: parent
                }

                MouseArea {
                    id: mousearea_
                    anchors.fill: parent

                    // Присваиваем свойству hoverEnabled значение
                    // true и разрешаем обработку события попадания мыши.
                    hoverEnabled: true

                    // В обработчике вхождения
                    // курсора мыши onEntered в область мыши MouseArea устанавливаем красный цвет:
                    onEntered: parent.color = "red"

                    // А в обработчике
                    // покидания onExited устанавливается светло-зеленый цвет:
                    onExited: parent.color = "lightgreen"
                }
            }




        }
    }

}
