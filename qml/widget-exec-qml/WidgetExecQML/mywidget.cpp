#include "mywidget.h"




/*
Класс QQuickWidget интегрирован в QML и предоставляет хорошую среду для показа и
визуализаuии QМL-элементов. Он базируется на классе QWidget, то есть это не что иное, как
виджет, а следовательно, его и надо использовать как обычный виджет в вашем коде на
Qt/C++. Таким образом, вы можете расположить этот виджет в области другого виджета,
используя класс размещения или задав позицию. Этот класс расположен в отдельном модуле
quickwidgets, который необходимо включить в проектный файл.
*/
#include <QQuickWidget>

#include <QVBoxLayout>
#include <QQuickItem>




MyWidget::MyWidget(QWidget *parent) :
    QWidget(parent)
{


    // Создаем объект класса QQuickWidget и
    // загружаем в конструкторе из ресурса файл main.qml, в котором находится
    // исходный текст программы на языке QML:
    QQuickWidget* pv = new QQuickWidget(QUrl("qrc:/main.qml") );

    // Размещаем его на поверхности
    // виджета класса MyWidget при помощи класса размещения QVBoxLayout:
    QVBoxLayout* pvbx = new QVBoxLayout;
    pvbx->addWidget(pv);
    setLayout(pvbx);


    // Получаем вызовом метода QQuickWidget::rootObject() указатель на узловой
    // объект QQuickitem:
    QQuickItem* pqiRoot = pv->rootObject();
    // Этим объектом, если посмотреть QML, является элемент Rectangle.

    if (pqiRoot) {

        // Так как класс QQuickItem унаследован от класса QObject, мы вызываем его метод
        // setProperty(), в который передаем имя свойства, его новое значение и изменяем тем самым
        // цвет фона этого элемента на желтый:
        pqiRoot->setProperty("color", "yellow");

        // Вызвав метод QObject::findChild() из узлового объекта pqiRoot
        // и передав ему имя искомого объекта в виде строки, мы получаем указатель на
        // элемент текста:
        QObject* pObjText = pqiRoot->findChild<QObject*>("text");

        if (pObjText) {

            // В элементе текста, при помощи двух методов QObject::setProperty(), мы
            // присваиваем другую строку свойству text и устанавливаем неиспользованному свойству
            // color голубой цвет:
            pObjText->setProperty("text", "С++");
            pObjText->setProperty("color", "blue");

            // Теперь пришла очередь вызвать функцию setFontSize() элемента Tехt.
            // Все функции в QМL-программе представлены в метаобъектной информации и, благодаря ей, могут
            // быть вызваны из С++. Для этого используется метод QMetaObject::invokeMethod().
            QVariant varRet;
            QMetaObject::invokeMethod(
                pObjText,  //  указатель на объект, который содержит эту функцию.
                "setFontSize",  //  имя функции.
                Q_RETURN_ARG(QVariant, varRet),  // указывается переменная, в которую функция должна вернуть значение.
                Q_ARG(QVariant, 52)  // размер шрифта в 48 пикселов.
            );
            // Если бы функция принимала два аргумента и более, то нужно было бы указать соответствующее
            // количество макросов Q_ARG. Все аргументы функции передаются посредством типа QVariant.
            // После вызова размер шрифта будет изменен.

            // А строку
            // с информацией о предыдущем размере шрифта, сохраненной в переменной varRet,
            // мы отобразим при помощи qDebug():
            qDebug () << varRet;
        }
    }


}

MyWidget::~MyWidget()
{
}
