import QtQuick 2.13
import QtQuick.Window 2.13
import QtQuick.Controls 1.4

Window {
    visible: true
    width: 640
    height: 480
    title: qsTr("Hello World")

    TabView {
        anchors.fill: parent
        Tab {
            title: "Узор"




            // Создаем элемент размерами 400х400, который содержит
            // элемент canvas:
            Item {
                width: 400
                height: 400

                // Элемент Canvas представляет собой элемент холста, на котором можно выполнять растровые
                // операции. С некоторыми допущениями он аналогичен классу контекста рисования
                // QPaintDevice, на котором можно рисовать при помощи объекта QPainter.

                Canvas {
                    // При помощи свойства anchors.fill мы заполняем все пространство
                    // окна:
                    anchors.fill: parent

                    // QML - это описательный язык, а значит, на этом языке мы не сможем реализовать
                    // алгоритмы для рисования, и для этой цели используется встроенный язык
                    // JavaScript. Элемента canvas предоставляет свойство обработки onPaint, которое можно
                    // сравнить с событием QWidget::paintEvent(). Внутри этого свойства и необходимо реализовать
                    // алгоритм рисования на JavaScript.

                    onPaint: {

                        // Алгоритм нашего узора мы оформим в виде отдельной функции drawFantasy(). В самой
                        // функции мы будем ссылаться на объект контекста рисования ctx, этот контекст мы получим
                        // в основной программе далее.
                        function drawFantasy()
                        {
                            // Вызовом метода beginPath() из объекта контекста рисования мы
                            // объявляем начало рисования графической траектории:
                            ctx.beginPath()

                            // Методом translate() производим
                            // трансформацию координат и смещаем ее в центр:
                            ctx.translate(parent.width / 2, parent.height / 2)

                            // Вычисляем угол в радианах:
                            var fAngle = 91 * 3.14156 / 180

                            // Запускаем цикл для рисования узора:
                            for (var i = 0; i < 300; ++i) {
                                var n = i * 2
                                ctx.moveTo(0, 0)  // для установки начальной точки.
                                ctx.lineTo(n, 0)  // рисовать линию.

                                // Проводим последующие трансформации перемещения и вращения:
                                ctx.translate(n, 0)
                                ctx.rotate(fAngle)
                            }

                            // Заканчиваем формирование нашей графической траектории:
                            ctx. closePath ()
                        }
                        var ctx = getContext("2d");  // получаем контекст рисования.
                        // Строковый аргумент "2d" говорит о том, что
                        // мы хотим рисовать на плоскости, используя две координаты: Х и У.

                        ctx.clearRect(0, 0, parent.width, parent.height)  // очищает всю область окна.

                        // Вызов save() из объекта контекста
                        // сохраняет его актуальное состояние - это очень важно, так как мы имеем дело не
                        // с объектом рисования, а непосредственно с самим контекстом, а поскольку он у элемента
                        // Canvas всего один, то необходимо следить за правильным сохранением его состояний.
                        ctx.save();

                        // Устанавливаем черный цвет для рисования линии:
                        ctx.strokeStyle = "black"

                        // Толщину линии устанавливаем равной 1:
                        ctx.lineWidth = 1

                        // Вызываем функцию drawFantasy() для задания траектории узора:
                        drawFantasy();

                        // Вызываем stroke() из объекта контекста рисования для его отображения:
                        ctx.stroke();

                        // В завершение мы восстанавливаем вызовом restore() исходное состояние контекста
                        // рисования, которое мы сохранили методом save():
                        ctx.restore();
                    }
                }
            }




        }
        Tab {
            title: "Градиент"




            // При помощи элемента холста можно отображать линейные градиенты.

            // Линейный градиент в прямоугольнике с рамкой:
            Canvas {
                id: canv
                width: 320
                height: 320
                onPaint: {
                    var ctx = getContext ( "2d")
                    ctx.strokeStyle = "Blue"  // цвет контурной линии.
                    ctx.lineWidth = 15

                    // Создаем объект градиента:
                    var gradient =
                    ctx.createLinearGradient(canv.width, canv.height, 0, 0)

                    // Оба прямоугольника имеют размеры, равные основному
                    // окну приложения, которые мы получаем посредством идентификатора canv.

                    // Создаем три точки останова методами:
                    gradient.addColorStop(0, "Indigo")
                    gradient.addColorStop(0.5, "Bisque")
                    gradient. addColorStop ( 1, "forestGreen")

                    // Присваиваем объекту графического
                    // контекста свойство fillStyle, которое отвечает за заполнение созданного нами
                    // градиента, и отображаем заполненный прямоугольник (метод fillRect() ).
                    ctx.fillStyle = gradient
                    ctx.fillRect(0, 0, canv.width, canv.height)

                    // Поверх заполненного прямоугольника отображаем прямоугольный контур:
                    ctx.strokeRect(0, 0, canv.width, canv.height)
                }
            }




        }
        Tab {
            title: "Шрифт со свечением"




            Canvas {
                id: canv_
                width: 400
                height: 160
                onPaint: {
                    var ctx = getContext ( "2d")

                    // Контекст рисования
                    // предоставляет свойства, при помощи которых можно придать отображаемым объектам
                    // немного стилевых эффектов:

                    // Задаем свойству заполнения fillStyle черный цвет:
                    ctx.fillStyle = "Black"

                    // Отображаем заполненный прямоугольник методом fillRect():
                    ctx.fillRect(0, 0, canv_.width, canv_.height);

                    // Затем задаем желтый цвет
                    // для рисования контуров (свойство strokeStyle):
                    ctx.strokeStyle = "Yellow"

                    // Устанавливаем цвет для тени тоже желтым
                    // (свойство shadowColor):
                    ctx.shadowColor = "Yellow";

                    // В нашем случае это конечно не тень, а свечение, так как оно
                    // отображается светлым цветом на темном фоне.

                    // Для достижения большего визуального
                    // эффекта осуществляем сдвиг нашего свечения по оси У на 5 пикселов (свойство
                    // shadowOffsetY):
                    ctx.shadowOffsetY = 5;

                    // Уровню размытия, которым управляет свойство shadowвlur, присваиваем
                    // значение 5:
                    ctx.shadowBlur = 5;

                    ctx.font = "48px Arial";  // тип и размер шрифта.
                    ctx.fillStyle = "Yellow";  // а также и цвет его заполнения.

                    // Для вывода текста на холсте можно использовать метод fillText():
                    ctx.fillText("Text with shadow 1", 10, canv_.height / 2);
                }
            }




        }
    }

}
